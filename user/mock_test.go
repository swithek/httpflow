// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package user

import (
	"context"
	"github.com/rs/xid"
	"github.com/swithek/httpflow"
	"sync"
)

// Ensure, that DBMock does implement DB.
// If this is not the case, regenerate this file with moq.
var _ DB = &DBMock{}

// DBMock is a mock implementation of DB.
//
//     func TestSomethingThatUsesDB(t *testing.T) {
//
//         // make and configure a mocked DB
//         mockedDB := &DBMock{
//             CreateUserFunc: func(ctx context.Context, usr User) error {
// 	               panic("mock out the CreateUser method")
//             },
//             DeleteUserByIDFunc: func(ctx context.Context, id xid.ID) error {
// 	               panic("mock out the DeleteUserByID method")
//             },
//             FetchManyUsersFunc: func(ctx context.Context, qr httpflow.Query) ([]User, error) {
// 	               panic("mock out the FetchManyUsers method")
//             },
//             FetchUserByEmailFunc: func(ctx context.Context, eml string) (User, error) {
// 	               panic("mock out the FetchUserByEmail method")
//             },
//             FetchUserByIDFunc: func(ctx context.Context, id xid.ID) (User, error) {
// 	               panic("mock out the FetchUserByID method")
//             },
//             UpdateUserFunc: func(ctx context.Context, usr User) error {
// 	               panic("mock out the UpdateUser method")
//             },
//             UserStatsFunc: func(ctx context.Context) (Stats, error) {
// 	               panic("mock out the UserStats method")
//             },
//         }
//
//         // use mockedDB in code that requires DB
//         // and then make assertions.
//
//     }
type DBMock struct {
	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(ctx context.Context, usr User) error

	// DeleteUserByIDFunc mocks the DeleteUserByID method.
	DeleteUserByIDFunc func(ctx context.Context, id xid.ID) error

	// FetchManyUsersFunc mocks the FetchManyUsers method.
	FetchManyUsersFunc func(ctx context.Context, qr httpflow.Query) ([]User, error)

	// FetchUserByEmailFunc mocks the FetchUserByEmail method.
	FetchUserByEmailFunc func(ctx context.Context, eml string) (User, error)

	// FetchUserByIDFunc mocks the FetchUserByID method.
	FetchUserByIDFunc func(ctx context.Context, id xid.ID) (User, error)

	// UpdateUserFunc mocks the UpdateUser method.
	UpdateUserFunc func(ctx context.Context, usr User) error

	// UserStatsFunc mocks the UserStats method.
	UserStatsFunc func(ctx context.Context) (Stats, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Usr is the usr argument value.
			Usr User
		}
		// DeleteUserByID holds details about calls to the DeleteUserByID method.
		DeleteUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID xid.ID
		}
		// FetchManyUsers holds details about calls to the FetchManyUsers method.
		FetchManyUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Qr is the qr argument value.
			Qr httpflow.Query
		}
		// FetchUserByEmail holds details about calls to the FetchUserByEmail method.
		FetchUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Eml is the eml argument value.
			Eml string
		}
		// FetchUserByID holds details about calls to the FetchUserByID method.
		FetchUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID xid.ID
		}
		// UpdateUser holds details about calls to the UpdateUser method.
		UpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Usr is the usr argument value.
			Usr User
		}
		// UserStats holds details about calls to the UserStats method.
		UserStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockCreateUser       sync.RWMutex
	lockDeleteUserByID   sync.RWMutex
	lockFetchManyUsers   sync.RWMutex
	lockFetchUserByEmail sync.RWMutex
	lockFetchUserByID    sync.RWMutex
	lockUpdateUser       sync.RWMutex
	lockUserStats        sync.RWMutex
}

// CreateUser calls CreateUserFunc.
func (mock *DBMock) CreateUser(ctx context.Context, usr User) error {
	if mock.CreateUserFunc == nil {
		panic("DBMock.CreateUserFunc: method is nil but DB.CreateUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Usr User
	}{
		Ctx: ctx,
		Usr: usr,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(ctx, usr)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//     len(mockedDB.CreateUserCalls())
func (mock *DBMock) CreateUserCalls() []struct {
	Ctx context.Context
	Usr User
} {
	var calls []struct {
		Ctx context.Context
		Usr User
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// DeleteUserByID calls DeleteUserByIDFunc.
func (mock *DBMock) DeleteUserByID(ctx context.Context, id xid.ID) error {
	if mock.DeleteUserByIDFunc == nil {
		panic("DBMock.DeleteUserByIDFunc: method is nil but DB.DeleteUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  xid.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteUserByID.Lock()
	mock.calls.DeleteUserByID = append(mock.calls.DeleteUserByID, callInfo)
	mock.lockDeleteUserByID.Unlock()
	return mock.DeleteUserByIDFunc(ctx, id)
}

// DeleteUserByIDCalls gets all the calls that were made to DeleteUserByID.
// Check the length with:
//     len(mockedDB.DeleteUserByIDCalls())
func (mock *DBMock) DeleteUserByIDCalls() []struct {
	Ctx context.Context
	ID  xid.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  xid.ID
	}
	mock.lockDeleteUserByID.RLock()
	calls = mock.calls.DeleteUserByID
	mock.lockDeleteUserByID.RUnlock()
	return calls
}

// FetchManyUsers calls FetchManyUsersFunc.
func (mock *DBMock) FetchManyUsers(ctx context.Context, qr httpflow.Query) ([]User, error) {
	if mock.FetchManyUsersFunc == nil {
		panic("DBMock.FetchManyUsersFunc: method is nil but DB.FetchManyUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Qr  httpflow.Query
	}{
		Ctx: ctx,
		Qr:  qr,
	}
	mock.lockFetchManyUsers.Lock()
	mock.calls.FetchManyUsers = append(mock.calls.FetchManyUsers, callInfo)
	mock.lockFetchManyUsers.Unlock()
	return mock.FetchManyUsersFunc(ctx, qr)
}

// FetchManyUsersCalls gets all the calls that were made to FetchManyUsers.
// Check the length with:
//     len(mockedDB.FetchManyUsersCalls())
func (mock *DBMock) FetchManyUsersCalls() []struct {
	Ctx context.Context
	Qr  httpflow.Query
} {
	var calls []struct {
		Ctx context.Context
		Qr  httpflow.Query
	}
	mock.lockFetchManyUsers.RLock()
	calls = mock.calls.FetchManyUsers
	mock.lockFetchManyUsers.RUnlock()
	return calls
}

// FetchUserByEmail calls FetchUserByEmailFunc.
func (mock *DBMock) FetchUserByEmail(ctx context.Context, eml string) (User, error) {
	if mock.FetchUserByEmailFunc == nil {
		panic("DBMock.FetchUserByEmailFunc: method is nil but DB.FetchUserByEmail was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Eml string
	}{
		Ctx: ctx,
		Eml: eml,
	}
	mock.lockFetchUserByEmail.Lock()
	mock.calls.FetchUserByEmail = append(mock.calls.FetchUserByEmail, callInfo)
	mock.lockFetchUserByEmail.Unlock()
	return mock.FetchUserByEmailFunc(ctx, eml)
}

// FetchUserByEmailCalls gets all the calls that were made to FetchUserByEmail.
// Check the length with:
//     len(mockedDB.FetchUserByEmailCalls())
func (mock *DBMock) FetchUserByEmailCalls() []struct {
	Ctx context.Context
	Eml string
} {
	var calls []struct {
		Ctx context.Context
		Eml string
	}
	mock.lockFetchUserByEmail.RLock()
	calls = mock.calls.FetchUserByEmail
	mock.lockFetchUserByEmail.RUnlock()
	return calls
}

// FetchUserByID calls FetchUserByIDFunc.
func (mock *DBMock) FetchUserByID(ctx context.Context, id xid.ID) (User, error) {
	if mock.FetchUserByIDFunc == nil {
		panic("DBMock.FetchUserByIDFunc: method is nil but DB.FetchUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  xid.ID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchUserByID.Lock()
	mock.calls.FetchUserByID = append(mock.calls.FetchUserByID, callInfo)
	mock.lockFetchUserByID.Unlock()
	return mock.FetchUserByIDFunc(ctx, id)
}

// FetchUserByIDCalls gets all the calls that were made to FetchUserByID.
// Check the length with:
//     len(mockedDB.FetchUserByIDCalls())
func (mock *DBMock) FetchUserByIDCalls() []struct {
	Ctx context.Context
	ID  xid.ID
} {
	var calls []struct {
		Ctx context.Context
		ID  xid.ID
	}
	mock.lockFetchUserByID.RLock()
	calls = mock.calls.FetchUserByID
	mock.lockFetchUserByID.RUnlock()
	return calls
}

// UpdateUser calls UpdateUserFunc.
func (mock *DBMock) UpdateUser(ctx context.Context, usr User) error {
	if mock.UpdateUserFunc == nil {
		panic("DBMock.UpdateUserFunc: method is nil but DB.UpdateUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Usr User
	}{
		Ctx: ctx,
		Usr: usr,
	}
	mock.lockUpdateUser.Lock()
	mock.calls.UpdateUser = append(mock.calls.UpdateUser, callInfo)
	mock.lockUpdateUser.Unlock()
	return mock.UpdateUserFunc(ctx, usr)
}

// UpdateUserCalls gets all the calls that were made to UpdateUser.
// Check the length with:
//     len(mockedDB.UpdateUserCalls())
func (mock *DBMock) UpdateUserCalls() []struct {
	Ctx context.Context
	Usr User
} {
	var calls []struct {
		Ctx context.Context
		Usr User
	}
	mock.lockUpdateUser.RLock()
	calls = mock.calls.UpdateUser
	mock.lockUpdateUser.RUnlock()
	return calls
}

// UserStats calls UserStatsFunc.
func (mock *DBMock) UserStats(ctx context.Context) (Stats, error) {
	if mock.UserStatsFunc == nil {
		panic("DBMock.UserStatsFunc: method is nil but DB.UserStats was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockUserStats.Lock()
	mock.calls.UserStats = append(mock.calls.UserStats, callInfo)
	mock.lockUserStats.Unlock()
	return mock.UserStatsFunc(ctx)
}

// UserStatsCalls gets all the calls that were made to UserStats.
// Check the length with:
//     len(mockedDB.UserStatsCalls())
func (mock *DBMock) UserStatsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockUserStats.RLock()
	calls = mock.calls.UserStats
	mock.lockUserStats.RUnlock()
	return calls
}

// Ensure, that EmailSenderMock does implement EmailSender.
// If this is not the case, regenerate this file with moq.
var _ EmailSender = &EmailSenderMock{}

// EmailSenderMock is a mock implementation of EmailSender.
//
//     func TestSomethingThatUsesEmailSender(t *testing.T) {
//
//         // make and configure a mocked EmailSender
//         mockedEmailSender := &EmailSenderMock{
//             SendAccountActivationFunc: func(ctx context.Context, eml string, tok string)  {
// 	               panic("mock out the SendAccountActivation method")
//             },
//             SendAccountDeletedFunc: func(ctx context.Context, eml string)  {
// 	               panic("mock out the SendAccountDeleted method")
//             },
//             SendAccountRecoveryFunc: func(ctx context.Context, eml string, tok string)  {
// 	               panic("mock out the SendAccountRecovery method")
//             },
//             SendEmailChangedFunc: func(ctx context.Context, oEml string, nEml string)  {
// 	               panic("mock out the SendEmailChanged method")
//             },
//             SendEmailVerificationFunc: func(ctx context.Context, eml string, tok string)  {
// 	               panic("mock out the SendEmailVerification method")
//             },
//             SendPasswordChangedFunc: func(ctx context.Context, eml string, recov bool)  {
// 	               panic("mock out the SendPasswordChanged method")
//             },
//         }
//
//         // use mockedEmailSender in code that requires EmailSender
//         // and then make assertions.
//
//     }
type EmailSenderMock struct {
	// SendAccountActivationFunc mocks the SendAccountActivation method.
	SendAccountActivationFunc func(ctx context.Context, eml string, tok string)

	// SendAccountDeletedFunc mocks the SendAccountDeleted method.
	SendAccountDeletedFunc func(ctx context.Context, eml string)

	// SendAccountRecoveryFunc mocks the SendAccountRecovery method.
	SendAccountRecoveryFunc func(ctx context.Context, eml string, tok string)

	// SendEmailChangedFunc mocks the SendEmailChanged method.
	SendEmailChangedFunc func(ctx context.Context, oEml string, nEml string)

	// SendEmailVerificationFunc mocks the SendEmailVerification method.
	SendEmailVerificationFunc func(ctx context.Context, eml string, tok string)

	// SendPasswordChangedFunc mocks the SendPasswordChanged method.
	SendPasswordChangedFunc func(ctx context.Context, eml string, recov bool)

	// calls tracks calls to the methods.
	calls struct {
		// SendAccountActivation holds details about calls to the SendAccountActivation method.
		SendAccountActivation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Eml is the eml argument value.
			Eml string
			// Tok is the tok argument value.
			Tok string
		}
		// SendAccountDeleted holds details about calls to the SendAccountDeleted method.
		SendAccountDeleted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Eml is the eml argument value.
			Eml string
		}
		// SendAccountRecovery holds details about calls to the SendAccountRecovery method.
		SendAccountRecovery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Eml is the eml argument value.
			Eml string
			// Tok is the tok argument value.
			Tok string
		}
		// SendEmailChanged holds details about calls to the SendEmailChanged method.
		SendEmailChanged []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OEml is the oEml argument value.
			OEml string
			// NEml is the nEml argument value.
			NEml string
		}
		// SendEmailVerification holds details about calls to the SendEmailVerification method.
		SendEmailVerification []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Eml is the eml argument value.
			Eml string
			// Tok is the tok argument value.
			Tok string
		}
		// SendPasswordChanged holds details about calls to the SendPasswordChanged method.
		SendPasswordChanged []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Eml is the eml argument value.
			Eml string
			// Recov is the recov argument value.
			Recov bool
		}
	}
	lockSendAccountActivation sync.RWMutex
	lockSendAccountDeleted    sync.RWMutex
	lockSendAccountRecovery   sync.RWMutex
	lockSendEmailChanged      sync.RWMutex
	lockSendEmailVerification sync.RWMutex
	lockSendPasswordChanged   sync.RWMutex
}

// SendAccountActivation calls SendAccountActivationFunc.
func (mock *EmailSenderMock) SendAccountActivation(ctx context.Context, eml string, tok string) {
	if mock.SendAccountActivationFunc == nil {
		panic("EmailSenderMock.SendAccountActivationFunc: method is nil but EmailSender.SendAccountActivation was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Eml string
		Tok string
	}{
		Ctx: ctx,
		Eml: eml,
		Tok: tok,
	}
	mock.lockSendAccountActivation.Lock()
	mock.calls.SendAccountActivation = append(mock.calls.SendAccountActivation, callInfo)
	mock.lockSendAccountActivation.Unlock()
	mock.SendAccountActivationFunc(ctx, eml, tok)
}

// SendAccountActivationCalls gets all the calls that were made to SendAccountActivation.
// Check the length with:
//     len(mockedEmailSender.SendAccountActivationCalls())
func (mock *EmailSenderMock) SendAccountActivationCalls() []struct {
	Ctx context.Context
	Eml string
	Tok string
} {
	var calls []struct {
		Ctx context.Context
		Eml string
		Tok string
	}
	mock.lockSendAccountActivation.RLock()
	calls = mock.calls.SendAccountActivation
	mock.lockSendAccountActivation.RUnlock()
	return calls
}

// SendAccountDeleted calls SendAccountDeletedFunc.
func (mock *EmailSenderMock) SendAccountDeleted(ctx context.Context, eml string) {
	if mock.SendAccountDeletedFunc == nil {
		panic("EmailSenderMock.SendAccountDeletedFunc: method is nil but EmailSender.SendAccountDeleted was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Eml string
	}{
		Ctx: ctx,
		Eml: eml,
	}
	mock.lockSendAccountDeleted.Lock()
	mock.calls.SendAccountDeleted = append(mock.calls.SendAccountDeleted, callInfo)
	mock.lockSendAccountDeleted.Unlock()
	mock.SendAccountDeletedFunc(ctx, eml)
}

// SendAccountDeletedCalls gets all the calls that were made to SendAccountDeleted.
// Check the length with:
//     len(mockedEmailSender.SendAccountDeletedCalls())
func (mock *EmailSenderMock) SendAccountDeletedCalls() []struct {
	Ctx context.Context
	Eml string
} {
	var calls []struct {
		Ctx context.Context
		Eml string
	}
	mock.lockSendAccountDeleted.RLock()
	calls = mock.calls.SendAccountDeleted
	mock.lockSendAccountDeleted.RUnlock()
	return calls
}

// SendAccountRecovery calls SendAccountRecoveryFunc.
func (mock *EmailSenderMock) SendAccountRecovery(ctx context.Context, eml string, tok string) {
	if mock.SendAccountRecoveryFunc == nil {
		panic("EmailSenderMock.SendAccountRecoveryFunc: method is nil but EmailSender.SendAccountRecovery was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Eml string
		Tok string
	}{
		Ctx: ctx,
		Eml: eml,
		Tok: tok,
	}
	mock.lockSendAccountRecovery.Lock()
	mock.calls.SendAccountRecovery = append(mock.calls.SendAccountRecovery, callInfo)
	mock.lockSendAccountRecovery.Unlock()
	mock.SendAccountRecoveryFunc(ctx, eml, tok)
}

// SendAccountRecoveryCalls gets all the calls that were made to SendAccountRecovery.
// Check the length with:
//     len(mockedEmailSender.SendAccountRecoveryCalls())
func (mock *EmailSenderMock) SendAccountRecoveryCalls() []struct {
	Ctx context.Context
	Eml string
	Tok string
} {
	var calls []struct {
		Ctx context.Context
		Eml string
		Tok string
	}
	mock.lockSendAccountRecovery.RLock()
	calls = mock.calls.SendAccountRecovery
	mock.lockSendAccountRecovery.RUnlock()
	return calls
}

// SendEmailChanged calls SendEmailChangedFunc.
func (mock *EmailSenderMock) SendEmailChanged(ctx context.Context, oEml string, nEml string) {
	if mock.SendEmailChangedFunc == nil {
		panic("EmailSenderMock.SendEmailChangedFunc: method is nil but EmailSender.SendEmailChanged was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		OEml string
		NEml string
	}{
		Ctx:  ctx,
		OEml: oEml,
		NEml: nEml,
	}
	mock.lockSendEmailChanged.Lock()
	mock.calls.SendEmailChanged = append(mock.calls.SendEmailChanged, callInfo)
	mock.lockSendEmailChanged.Unlock()
	mock.SendEmailChangedFunc(ctx, oEml, nEml)
}

// SendEmailChangedCalls gets all the calls that were made to SendEmailChanged.
// Check the length with:
//     len(mockedEmailSender.SendEmailChangedCalls())
func (mock *EmailSenderMock) SendEmailChangedCalls() []struct {
	Ctx  context.Context
	OEml string
	NEml string
} {
	var calls []struct {
		Ctx  context.Context
		OEml string
		NEml string
	}
	mock.lockSendEmailChanged.RLock()
	calls = mock.calls.SendEmailChanged
	mock.lockSendEmailChanged.RUnlock()
	return calls
}

// SendEmailVerification calls SendEmailVerificationFunc.
func (mock *EmailSenderMock) SendEmailVerification(ctx context.Context, eml string, tok string) {
	if mock.SendEmailVerificationFunc == nil {
		panic("EmailSenderMock.SendEmailVerificationFunc: method is nil but EmailSender.SendEmailVerification was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Eml string
		Tok string
	}{
		Ctx: ctx,
		Eml: eml,
		Tok: tok,
	}
	mock.lockSendEmailVerification.Lock()
	mock.calls.SendEmailVerification = append(mock.calls.SendEmailVerification, callInfo)
	mock.lockSendEmailVerification.Unlock()
	mock.SendEmailVerificationFunc(ctx, eml, tok)
}

// SendEmailVerificationCalls gets all the calls that were made to SendEmailVerification.
// Check the length with:
//     len(mockedEmailSender.SendEmailVerificationCalls())
func (mock *EmailSenderMock) SendEmailVerificationCalls() []struct {
	Ctx context.Context
	Eml string
	Tok string
} {
	var calls []struct {
		Ctx context.Context
		Eml string
		Tok string
	}
	mock.lockSendEmailVerification.RLock()
	calls = mock.calls.SendEmailVerification
	mock.lockSendEmailVerification.RUnlock()
	return calls
}

// SendPasswordChanged calls SendPasswordChangedFunc.
func (mock *EmailSenderMock) SendPasswordChanged(ctx context.Context, eml string, recov bool) {
	if mock.SendPasswordChangedFunc == nil {
		panic("EmailSenderMock.SendPasswordChangedFunc: method is nil but EmailSender.SendPasswordChanged was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Eml   string
		Recov bool
	}{
		Ctx:   ctx,
		Eml:   eml,
		Recov: recov,
	}
	mock.lockSendPasswordChanged.Lock()
	mock.calls.SendPasswordChanged = append(mock.calls.SendPasswordChanged, callInfo)
	mock.lockSendPasswordChanged.Unlock()
	mock.SendPasswordChangedFunc(ctx, eml, recov)
}

// SendPasswordChangedCalls gets all the calls that were made to SendPasswordChanged.
// Check the length with:
//     len(mockedEmailSender.SendPasswordChangedCalls())
func (mock *EmailSenderMock) SendPasswordChangedCalls() []struct {
	Ctx   context.Context
	Eml   string
	Recov bool
} {
	var calls []struct {
		Ctx   context.Context
		Eml   string
		Recov bool
	}
	mock.lockSendPasswordChanged.RLock()
	calls = mock.calls.SendPasswordChanged
	mock.lockSendPasswordChanged.RUnlock()
	return calls
}
